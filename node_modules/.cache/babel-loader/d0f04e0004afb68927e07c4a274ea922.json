{"ast":null,"code":"export function configureFakeBackend(){var users=[{id:1,username:'test',password:'test',firstName:'Tesst',lastName:'Usser'}];var realFetch=window.fetch;window.fetch=function(url,opts){return new Promise(function(resolve,reject){// wrap in timeout to simulate server api call\nsetTimeout(function(){// authenticate\nif(url.endsWith('/users/authenticate')&&opts.method==='POST'){// get parameters from post request\nvar params=JSON.parse(opts.body);// find if any user matches login credentials\nvar filteredUsers=users.filter(function(user){return user.username===params.username&&user.password===params.password;});if(filteredUsers.length){// if login details are valid return user details\nvar user=filteredUsers[0];var responseJson={id:user.id,username:user.username,firstName:user.firstName,lastName:user.lastName};resolve({ok:true,text:function text(){return Promise.resolve(JSON.stringify(responseJson));}});}else{// else return error\nreject('Username or password is incorrect');}return;}// get users\nif(url.endsWith('/users')&&opts.method==='GET'){// check for fake auth token in header and return users if valid, this security \n// is implemented server side in a real application\nif(opts.headers&&opts.headers.Authorization===\"Basic \".concat(window.btoa('test:test'))){resolve({ok:true,text:function text(){return Promise.resolve(JSON.stringify(users));}});}else{// return 401 not authorised if token is null or invalid\nresolve({status:401,text:function text(){return Promise.resolve();}});}return;}// pass through any requests not handled above\nrealFetch(url,opts).then(function(response){return resolve(response);});},500);});};}","map":{"version":3,"sources":["/home/praveesh/Desktop/github/parkzeus/src/Pages/Login/_helpers/fake-backend.js"],"names":["configureFakeBackend","users","id","username","password","firstName","lastName","realFetch","window","fetch","url","opts","Promise","resolve","reject","setTimeout","endsWith","method","params","JSON","parse","body","filteredUsers","filter","user","length","responseJson","ok","text","stringify","headers","Authorization","btoa","status","then","response"],"mappings":"AAAA,MAAO,SAASA,CAAAA,oBAAT,EAAgC,CACnC,GAAIC,CAAAA,KAAK,CAAG,CAAC,CAAEC,EAAE,CAAE,CAAN,CAASC,QAAQ,CAAE,MAAnB,CAA2BC,QAAQ,CAAE,MAArC,CAA6CC,SAAS,CAAE,OAAxD,CAAiEC,QAAQ,CAAE,OAA3E,CAAD,CAAZ,CACA,GAAIC,CAAAA,SAAS,CAAGC,MAAM,CAACC,KAAvB,CACAD,MAAM,CAACC,KAAP,CAAe,SAAUC,GAAV,CAAeC,IAAf,CAAqB,CAChC,MAAO,IAAIC,CAAAA,OAAJ,CAAY,SAACC,OAAD,CAAUC,MAAV,CAAqB,CACpC;AACAC,UAAU,CAAC,UAAM,CAEb;AACA,GAAIL,GAAG,CAACM,QAAJ,CAAa,qBAAb,GAAuCL,IAAI,CAACM,MAAL,GAAgB,MAA3D,CAAmE,CAC/D;AACA,GAAIC,CAAAA,MAAM,CAAGC,IAAI,CAACC,KAAL,CAAWT,IAAI,CAACU,IAAhB,CAAb,CAEA;AACA,GAAIC,CAAAA,aAAa,CAAGrB,KAAK,CAACsB,MAAN,CAAa,SAAAC,IAAI,CAAI,CACrC,MAAOA,CAAAA,IAAI,CAACrB,QAAL,GAAkBe,MAAM,CAACf,QAAzB,EAAqCqB,IAAI,CAACpB,QAAL,GAAkBc,MAAM,CAACd,QAArE,CACH,CAFmB,CAApB,CAIA,GAAIkB,aAAa,CAACG,MAAlB,CAA0B,CACtB;AACA,GAAID,CAAAA,IAAI,CAAGF,aAAa,CAAC,CAAD,CAAxB,CACA,GAAII,CAAAA,YAAY,CAAG,CACfxB,EAAE,CAAEsB,IAAI,CAACtB,EADM,CAEfC,QAAQ,CAAEqB,IAAI,CAACrB,QAFA,CAGfE,SAAS,CAAEmB,IAAI,CAACnB,SAHD,CAIfC,QAAQ,CAAEkB,IAAI,CAAClB,QAJA,CAAnB,CAMAO,OAAO,CAAC,CAAEc,EAAE,CAAE,IAAN,CAAYC,IAAI,CAAE,sBAAMhB,CAAAA,OAAO,CAACC,OAAR,CAAgBM,IAAI,CAACU,SAAL,CAAeH,YAAf,CAAhB,CAAN,EAAlB,CAAD,CAAP,CACH,CAVD,IAUO,CACH;AACAZ,MAAM,CAAC,mCAAD,CAAN,CACH,CAED,OACH,CAED;AACA,GAAIJ,GAAG,CAACM,QAAJ,CAAa,QAAb,GAA0BL,IAAI,CAACM,MAAL,GAAgB,KAA9C,CAAqD,CACjD;AACA;AACA,GAAIN,IAAI,CAACmB,OAAL,EAAgBnB,IAAI,CAACmB,OAAL,CAAaC,aAAb,mBAAwCvB,MAAM,CAACwB,IAAP,CAAY,WAAZ,CAAxC,CAApB,CAAwF,CACpFnB,OAAO,CAAC,CAAEc,EAAE,CAAE,IAAN,CAAYC,IAAI,CAAE,sBAAMhB,CAAAA,OAAO,CAACC,OAAR,CAAgBM,IAAI,CAACU,SAAL,CAAe5B,KAAf,CAAhB,CAAN,EAAlB,CAAD,CAAP,CACH,CAFD,IAEO,CACH;AACAY,OAAO,CAAC,CAAEoB,MAAM,CAAE,GAAV,CAAeL,IAAI,CAAE,sBAAMhB,CAAAA,OAAO,CAACC,OAAR,EAAN,EAArB,CAAD,CAAP,CACH,CAED,OACH,CAED;AACAN,SAAS,CAACG,GAAD,CAAMC,IAAN,CAAT,CAAqBuB,IAArB,CAA0B,SAAAC,QAAQ,QAAItB,CAAAA,OAAO,CAACsB,QAAD,CAAX,EAAlC,EAEH,CA/CS,CA+CP,GA/CO,CAAV,CAgDH,CAlDM,CAAP,CAmDH,CApDD,CAqDH","sourcesContent":["export function configureFakeBackend() {\n    let users = [{ id: 1, username: 'test', password: 'test', firstName: 'Tesst', lastName: 'Usser' }];\n    let realFetch = window.fetch;\n    window.fetch = function (url, opts) {\n        return new Promise((resolve, reject) => {\n            // wrap in timeout to simulate server api call\n            setTimeout(() => {\n\n                // authenticate\n                if (url.endsWith('/users/authenticate') && opts.method === 'POST') {\n                    // get parameters from post request\n                    let params = JSON.parse(opts.body);\n\n                    // find if any user matches login credentials\n                    let filteredUsers = users.filter(user => {\n                        return user.username === params.username && user.password === params.password;\n                    });\n\n                    if (filteredUsers.length) {\n                        // if login details are valid return user details\n                        let user = filteredUsers[0];\n                        let responseJson = {\n                            id: user.id,\n                            username: user.username,\n                            firstName: user.firstName,\n                            lastName: user.lastName\n                        };\n                        resolve({ ok: true, text: () => Promise.resolve(JSON.stringify(responseJson)) });\n                    } else {\n                        // else return error\n                        reject('Username or password is incorrect');\n                    }\n\n                    return;\n                }\n\n                // get users\n                if (url.endsWith('/users') && opts.method === 'GET') {\n                    // check for fake auth token in header and return users if valid, this security \n                    // is implemented server side in a real application\n                    if (opts.headers && opts.headers.Authorization === `Basic ${window.btoa('test:test')}`) {\n                        resolve({ ok: true, text: () => Promise.resolve(JSON.stringify(users)) });\n                    } else {\n                        // return 401 not authorised if token is null or invalid\n                        resolve({ status: 401, text: () => Promise.resolve() });\n                    }\n\n                    return;\n                }\n\n                // pass through any requests not handled above\n                realFetch(url, opts).then(response => resolve(response));\n\n            }, 500);\n        });\n    }\n}"]},"metadata":{},"sourceType":"module"}